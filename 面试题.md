## 面试题收集



### Java基础

#### Java语言特点

1. 面向对象（封装继承多态）
2. 跨平台（JVM）
3. 可靠性（异常处理和垃圾回收）
4. 安全性（权限修饰符）
5. 高效性（即时编译器JIT）
6. 多线程支持



#### JDK JVM JRE

1. JVM是运行 Java 字节码的虚拟机。JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。
2. JRE是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 JVM、Java 基础类库。
3. JDK，它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。
4. ![image-20240312182710999](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240312182710999.png)



#### 字节码

1. 字节码是 Java 程序编译后的中间代码，是⼀种可移植的⼆进制代码，可以在任何⽀持 Java 虚拟机（JVM）的平台 上运行。采⽤字节码作为中间代码的最⼤好处是提⾼了 Java 程序的可移植性、安全性、性能和可读性。
2. ![image-20240312223752830](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240312223752830.png)



#### final 关键字

1. 修饰变量

   将变量定义为常量，final int MAX_NUM = 100;
   在对象引用声明前加上 final 关键字，可以确保该引用指向的对象不能被改变，但是该对象的内容可以被改变。

2. 修饰方法
   防止该方法被子类重写

3. 修饰类
   防止类被继承，定义一个不可继承的类



#### hashCode 、 equals 和 == 

在 Java 中，hashCode 和 equals 方法都是 Object 类的方法。

1. hashCode 方法返回对象的哈希码，是一个int类型的数值，如果它们的哈希码不同，那么它们肯定不相等
   注意：因为hashCode 可能会出现 hash 碰撞，所以导致不相等的两个对象 hash 码可能相等
2. equals 方法返回一个布尔值，一般需要重写，比较的是两个变量的内容
3. == ⽤来判断两个对象的地址是否相同



#### Java中的反射

1. Java的反射机制是指在运⾏时获得类的信息，创建类的对象，调⽤其中的⽅法和属性。
2. 优点：动态的，比较灵活
3. 缺点：运行效率较低，破坏封装性，使代码变得复杂
4. 应用场景：动态代理、单元测试、 RPC 框架



#### 四种访问修饰符

Java 提供了四种访问修饰符，用于控制访问范围，分别为 public、private、protected 和默认（⽆修饰符）。

![image-20240318165708930](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240318165708930.png)



#### StringBuffer和StringBuilder

1. String是不可变的，每次修改都会创建一个新对象，字符串需要频繁修改时，建议使⽤ StringBuffer或StringBuilder
2. StringBuilder是可变的对象，线程不安全，性能较高
3. StringBuffer是可变的对象，线程安全，但性能较低



#### 内部类

1. 成员内部类：定义在类内部，但在⽅法外部的类。它可以访问外部类的所有成员变量和⽅法
2. 静态内部类：定义在类内部，但使⽤ static 修饰的类。它只能访问外部类的静态成员变量和⽅法 
3. 局部内部类：定义在⽅法内部的类。它只能访问⽅法内部的 final 变量和⽅法参数
4. 匿名内部类：没有类名的内部类，通常⽤于创建只需要使⽤⼀次的类



#### 基本类型和包装类型的区别

|          | 包装类型                         | 基本类型                                               |
| -------- | -------------------------------- | ------------------------------------------------------ |
| 用途     | 可用于泛型                       | 不可用于泛型                                           |
| 占用空间 | 较大                             | 较小                                                   |
| 默认值   | `null`                           | 不是`null`                                             |
| 比较方式 | `==`比较地址，`equals()`比较内容 | `==`比较值                                             |
| 存储方式 | 存在堆中                         | 如果是局部变量，存放在栈中；如果是成员变量，存放在堆中 |





### Java集合

#### 集合的框架体系

![image-20240418134222497](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240418134222497.png)





### Java并发



#### 什么是线程 进程?

1. 进程是程序的一次执行过程，是操作系统调度和分配资源的最小单位。
2. 线程是程序内部的一条执行路径。一个进程中至少有一个线程，它们共享同一块内存。线程是 CPU 调度和执行的最小单位。



#### 什么是并发 并行？

1. 并发：系统中同时存在多个正在执⾏的任务。在单核 CPU 上，多个任务会**轮流使⽤ CPU 时间⽚**，看似同时执⾏，但实际上是交替执行的。
2. 并行：系统中同时存在多个并且相互独立的任务，真正意义上多任务同时执行。



#### 什么是同步 异步？

1. 同步：程序按照代码的顺序一行一行执行，必须等待函数或⽅法执⾏完毕才能继续往下执⾏。举例：线程同步问题
2. 异步：程序在执⾏某个任务时，不会⼀直等待任务完成，⽽是继续执⾏下一行代码，当任务完成后再进行相应的处理（回调）。异步通常不会阻塞调⽤者，可以**提⾼系统的并发性能**。





<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240415120830052.png" alt="image-20240415120830052" style="zoom: 50%;" />





#### Java创建线程的两种方式

1. 继承 Thread 类：线程代码存放 Thread 子类 run 方法中。
2. 实现 Runnable 接口：线程代码存在接口的子类的 run 方法。
3. 推荐使用实现 Runnable 接口的方式：
   1. 避免了单继承的局限性。
   2. 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。
   3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。



#### sleep()和wait()的区别

- 相同点
  1. 一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。
- 不同点
  1. 所属的类：sleep() 在 Thread 中定义； wait() 在 Object 中定义
  2. 使用范围：sleep() 任何位置； wait() 必须在同步代码块或同步方法中
  3. 是否释放同步监视器：sleep() 不释放;  wait() 释放
  4. 结束等待：sleep() 指定时间一到就结束阻塞；wait() 可指定时间，也可以无限等待直到 notify 或 notifyAll。





<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240416164312353.png" alt="image-20240416164312353" style="zoom:50%;" />







### Spring框架



#### @Autowird 与 @Resource的区别

1. @Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解
2. @Autowired 默认是**按照类型**注入，而@Resource是**按照名称**注入









### MySQL



#### 事务 ACID

数据库事务是⼀个操作序列，必须作为⼀个不可分割的单元执行，即要么全部执⾏成功，要么全部失败回滚。

1. 原子性（Atomicity）：事务是⼀个原子操作，要么全部提交，要么全部回滚。
2. ⼀致性（Consistency）：⼀致性是指在事务中，确保数据的**完整性和约束条件**。如 A 给 B 转账，不论转账的事务操作是否成功，其两者的存款总额不变。
3. 隔离性（Isolation）：多个事务并发访问时，事务之间是隔离的，⼀个事务不应该影响其它事务运⾏效果。使用不同的**隔离级别**，避免出现脏读、不可重复读、幻读等问题。
4. 持久性（Durability）：⼀旦事务提交，其所做的修改必须永久保存到数据库中。不可回滚，即使系统发⽣故障或宕机， 数据也能够保持不变。



#### MySQL 数据如何存放在文件中（物理存储）？

假设数据库a中有表b

- InnoDB模式
  1. MySQL 5.7 及之前： b.frm 存放表结构， b.ibd 存放数据和索引
  2. MySQL 8 之后：取消 .frm ，表结构合并到 b.ibd 中
- MyISAM模式
  1. 数据和索引分开存放：b.MYD (MYData) 存储数据，b.MYI (MYIndex)：存放索引
  2. MySQL 5.7 及之前： b.frm  存放表结构
  3. MySQL 8 之后：  b.xxx.sdi  存放表结构



#### SQL的执行过程

 SQL语句→查询缓存→解析器(词法分析+语法分析)→优化器→执行器

![image-20240320220936229](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240320220936229.png)



#### InnoDB对比MyISAM

1. MySQL ⽀持多种存储引擎，常⽤的有 InnoDB、MyISAM、Memory、Archive、CSV等，默认的是InnoDB
2. InnoDB和MyISAM的对比![image-20240326140238710](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240326140238710.png)
3. MyISAM一般用于对事务完整性没有要求或者以SELECT、INSERT为主的应用



#### Hash索引对比B+树？

1. **范围查询**：Hash索引仅能满足(=)(<>)和IN查询。如果进行范围查询，哈希型的索引，时间复杂度会退化为O(n);而树型的“有序”特性，依然能够保持O(log2N)的高效率。
2. **排序查找**：Hash索引还有一个缺陷，数据的存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。
3. **联合索引**：对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。
4. **重复值过多**：对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hsh冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。
5. 因此**数据库通常使用树形结构**

 



#### B+树的存储能力？为何一般查找只需1~3次磁盘IO

1. InnoDB存储引擎中页大小为16KB，一般键值对大小16B，因此一页大约存1000个键值对，假设一页存储1000行数据，一个深度为3的B+树能存大约**10亿条记录**。
2. 实际数据库中，B+树的高度一般是2-4层，但根节点一般**常驻在内存**中，因此一般是1-3次IO



#### B+树是如何进行记录检索的？

如果通过B+树的索引查询行记录，首先是从B+树的**根开始逐层检索**，直到找到叶子节点，也就是找到对应的数据页为止，将**数据页加载到内存**中，页目录中的**槽(slot)采用二分查找**的方式先找到一个粗略的记录分组，然后再在分组中通过**链表遍历**的方式查找记录。



#### 普通索引和唯一索引在查询效率上有什么不同？

唯一索引关键字唯一，找到了关键字就**停止检索**。而普通索引，可能会存在用户记录中的**关键字相同**的情况，根据页结构的原理，我们将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB,在一个页中可能存储着上干个记录，因此在普通索引的字段上进行查找也就是**在内存中多几次“判断下一条记录"的操作**，对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上**基本上没有差别**。



#### 什么是B+树 聚簇索引

![image-20240403233401198](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240403233401198.png)



#### 适合创建索引的情况

1. 字段的数值有唯一性的限制
2. 频繁作为 WHERE 查询条件的字段
3. 经常 GROUP BY 和 ORDER BY 的列
4. UPDATE、DELETE 的 WHERE 条件列
5. DISTINCT 字段需要创建索引
6. 多表 JOIN 连接操作时创建索引
7. 使用列的类型小的创建索引
8. 使用字符串前缀创建索引
9. 区分度高(散列性高)的列适合作为索引
10. 使用最频繁的列放到联合索引的左侧(最左前缀原则)
11. 在多个字段都要创建索引的情况下，联合索引优于单值索引



#### 不适合创建索引的情况

1. 在where中使用不到的字段，不要设置索引
2. 数据量小的表不需要使用索引，比如不到 1000 行
3. 有大量重复数据的列上不要建立索引
4. 避免对经常更新的表创建过多的索引
5. 不建议用无序的值作为索引
6. 删除不再使用或者很少使用的索引
7. 不要定义冗余或重复的索引





#### 多表 JOIN 连接操作时，创建索引注意事项

1. 首先， 连接表的数量尽量**不要超过 3 张** ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。
2. 其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。
3. 最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 **类型必须一致** 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。



3.24









### 设计模式



#### 单例模式 饿汉式与懒汉式

1. 饿汉式：立即加载，即在使用类的时候已经将对象创建完毕。没有多线程安全问题，但耗费内存。
2. 懒汉式：延迟加载，即在调用静态方法时实例才被创建。节约内存，但线程不安全。









### 操作系统

#### 死锁是什么？如何预防和避免死锁？

1. 死锁是指两个或多个进程在执⾏过程中因争夺资源而造成的⼀种僵局，当进程处于死锁状态时，它们将⽆法继续执
   ⾏，⽽只能相互等待，直到被外部的程序⼲预或⾃⾏放弃。
2. 四个产生死锁的必要条件
   1. 互斥
   2. 持有并等待
   3. 不可剥夺
   4. 环路等待
3. 避免死锁只需要破除四个条件中的一个



### 其他



#### 常见的限流策略

限流，也称流量控制。是指系统在面临高并发，或者**大流量请求**的情况下，**限制新的请求对系统的访问**，从而**保证系统的稳定性**。

1. **固定窗口**限流算法
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240414205227933.png" alt="image-20240414205227933" style="zoom:50%;" />
   缺点：会遇到**临界问题**

2. **滑动窗口**限流算法
   将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/file_1713099278363_702.png" alt="file_1713099278363_702" style="zoom:50%;" />
   缺点是：会损失一部分请求

3. 漏桶算法
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240414210109880.png" alt="image-20240414210109880" style="zoom:50%;" />
   缺点：**处理效率恒定**，无法迅速处理一批请求

4. 令牌桶算法

   较为常用的算法，能够**较好的处理高并发问题**

   - 有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。
   - 如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。
   - 收到一个请求，先去令牌桶要一个令牌。
   - 如果拿到令牌，处理请求。如果拿不到令牌，拒绝请求。

   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240414210251103.png" alt="image-20240414210251103" style="zoom:50%;" />

   

   

