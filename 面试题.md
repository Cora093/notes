# 面试题收集



## Java基础

### Java语言特点

1. 面向对象（封装继承多态）
2. 跨平台（JVM）
3. 可靠性（异常处理和垃圾回收）
4. 安全性（权限修饰符）
5. 高效性（即时编译器JIT）
6. 多线程支持



### JDK JVM JRE

1. JVM是运行 Java 字节码的虚拟机。JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。
2. JRE是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 JVM、Java 基础类库。
3. JDK，它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。
4. ![image-20240312182710999](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240312182710999.png)



### 字节码

1. 字节码是 Java 程序编译后的中间代码，是⼀种可移植的⼆进制代码，可以在任何⽀持 Java 虚拟机（JVM）的平台 上运行。采⽤字节码作为中间代码的最⼤好处是提⾼了 Java 程序的可移植性、安全性、性能和可读性。
2. ![image-20240312223752830](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240312223752830.png)



### final 关键字

1. 修饰变量

   将变量定义为常量，final int MAX_NUM = 100;
   在对象引用声明前加上 final 关键字，可以确保该引用指向的对象不能被改变，但是该对象的内容可以被改变。

2. 修饰方法
   防止该方法被子类重写

3. 修饰类
   防止类被继承，定义一个不可继承的类



### hashCode 、 equals 和 ==

在 Java 中，hashCode 和 equals 方法都是 Object 类的方法。

1. hashCode 方法返回对象的哈希码，是一个int类型的数值，如果它们的哈希码不同，那么它们肯定不相等
   注意：因为hashCode 可能会出现 hash 碰撞，所以导致不相等的两个对象 hash 码可能相等
2. equals 方法返回一个布尔值，一般需要重写，比较的是两个变量的内容
3. == ⽤来判断两个对象的地址是否相同



### Java中的反射

1. Java的反射机制是指在运⾏时获得类的信息，创建类的对象，调⽤其中的⽅法和属性。
2. 优点：动态的，比较灵活
3. 缺点：运行效率较低，破坏封装性，使代码变得复杂
4. 应用场景：动态代理、单元测试、 RPC 框架



### 四种访问修饰符

Java 提供了四种访问修饰符，用于控制访问范围，分别为 public、private、protected 和默认（⽆修饰符）。

![image-20240318165708930](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240318165708930.png)



### StringBuffer和StringBuilder

1. String是不可变的，每次修改都会创建一个新对象，字符串需要频繁修改时，建议使⽤ StringBuffer或StringBuilder
2. StringBuilder是可变的对象，线程不安全，性能较高
3. StringBuffer是可变的对象，线程安全，但性能较低



### 内部类

1. 成员内部类：定义在类内部，但在⽅法外部的类。它可以访问外部类的所有成员变量和⽅法
2. 静态内部类：定义在类内部，但使⽤ static 修饰的类。它只能访问外部类的静态成员变量和⽅法 
3. 局部内部类：定义在⽅法内部的类。它只能访问⽅法内部的 final 变量和⽅法参数
4. 匿名内部类：没有类名的内部类，通常⽤于创建只需要使⽤⼀次的类



### 基本类型和包装类型的区别

|          | 包装类型                         | 基本类型                                               |
| -------- | -------------------------------- | ------------------------------------------------------ |
| 用途     | 可用于泛型                       | 不可用于泛型                                           |
| 占用空间 | 较大                             | 较小                                                   |
| 默认值   | `null`                           | 不是`null`                                             |
| 比较方式 | `==`比较地址，`equals()`比较内容 | `==`比较值                                             |
| 存储方式 | 存在堆中                         | 如果是局部变量，存放在栈中；如果是成员变量，存放在堆中 |



### 异常的分类

<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240501171626530.png" alt="image-20240501171626530" style="zoom: 67%;" />

1. 在 Java 中，所有的异常都有一个共同的祖先， `java.lang` 包中的 **Throwable 类**。
2. Throwable 可分为两类：**Error 和 Exception**
   - Error 是 Java **虚拟机无法解决**的严重问题，例如 Java 虚拟机运行错误（`Virtual MachineError`）、StackOverflowError（栈内存溢出）和 OutOfMemoryError（堆内存溢出，简称**OOM**）
   - Exception 是程序本身可以处理的异常，可以通过 `catch` 来进行捕获
3. Exception 又可以进行分类
   - 编译时异常（受检异常）：编译器能识别，如果不处理代码不会通过，eg：IO流相关异常、FileNotFoundException
   - 运行时异常（RuntimeException 非受检异常）：编译器无法识别，运行时才会被发现，eg：`NullPointerException` (空指针错误)、`ArrayIndexOutOfBoundsException`（数组越界错误）



## Java集合

### map set 和 list 的区别

![image-20240418134222497](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240418134222497.png)



### ArrayList 的扩容机制

1. 当数组长度不够时，调用内部 grow() 方法，扩容到1.5倍
2. 底层 `Object[]` 数组的初始化
   1. jdk8以前：直接创建长度是 10 的 `Object[]` 数组
   2. jdk8以后：以无参构造方法创建 `ArrayList` 时，实际上初始化赋值的是一个**空数组**。当真正对数组进行添加元素操作时，才真正分配10容量。



### Arraylist 与 LinkedList 区别?

1. 是否保证**线程安全**： `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
2. 底层**数据结构**： `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构
3. 插入和删除是否受元素位置的影响：

   - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响，是O(n)。

   - `LinkedList` 采用双向链表存储，所以在头尾插入或者删除元素不受元素位置的影响，时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。
5. 内存空间占用： `ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。



### HashMap 底层相关

1. JDK1.8 之前底层是 数组+链表 -> JDK1.8 之后底层是**数组+链表+红黑树**
2. `HashMap` 可以存储 **null** 的 key 和 value
3. `HashMap` **扩容条件**：默认**负载因子**是 0.75，也就是说当元素数量达到容量的 0.75 倍时，会触发扩容操作，将数组长度翻倍
4. 链表**转红黑树条件**：数组长度>=64 且 链表长度>8
5. 红黑树相比于链表，具有有序性，查找效率更高



### HashMap 和 HashTable 有什么区别？

1. **线程是否安全：** `HashMap` 是非线程安全的，`Hashtable` 是线程安全的。

2. **底层数据结构：**`HashMap` JDK1.8 以后转红黑树。`Hashtable` 没有这样的机制。

3. **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰。

4. **哈希函数的实现**：`HashMap` 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 `Hashtable` 直接使用键的 `hashCode()` 值。

   

### LinkedHashMap 和 HashMap 的关系

1. `LinkedHashMap` 在 `HashMap`  使用的数组+单向链表+红黑树的基础上，又增加了一对双向链表，记录添加的key-value的**先后顺序**。便于我们遍历所有的key-value。
2. ![image-20240430211841427](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240430211841427.png)









## JUC



### 什么是线程 进程?

1. 进程是**程序的一次执行过程**，是操作系统调度和分配资源的最小单位。
2. 线程是程序内部的一条执行路径。一个进程中至少有一个线程，它们共享同一块内存。线程是 **CPU 调度和执行的最小单位**。



### 什么是并发 并行？

1. 并发：系统中同时存在多个正在执⾏的任务。在单核 CPU 上，多个任务会**轮流使⽤ CPU 时间⽚**，看似同时执⾏，但实际上是交替执行的。
2. 并行：系统中同时存在多个并且相互独立的任务，真正意义上多任务同时执行。



### 什么是同步 异步？

1. 同步：程序按照代码的顺序一行一行执行，必须等待函数或⽅法执⾏完毕才能继续往下执⾏。举例：线程同步问题
2. 异步：程序在执⾏某个任务时，不会⼀直等待任务完成，⽽是继续执⾏下一行代码，当任务完成后再进行相应的处理（回调）。异步通常不会阻塞调⽤者，可以**提⾼系统的并发性能**。





<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240415120830052.png" alt="image-20240415120830052" style="zoom: 50%;" />



### 解决 List 的线程安全问题

1. 使用 Vector
2. 使用 Collections.syncronizedList()
3. 使用 **CopyOnWriteArrayList** （最常用）
   写时复制：并发读，写时复制一个新数组，写完之后再合并



### Java创建线程的方式

1. 继承 Thread 类：线程代码存放 Thread 子类 run 方法中。
2. 实现 Runnable 接口：线程代码存在接口的子类的 run 方法。
3. 线程池和Callable也可以创建，但本质上也是通过前两种基本方式实现的
4. 两种创建线程方式**本质上是一样**的，它们的不同点仅仅在于实现线程**运行内容的不同**
5. **推荐**使用实现 Runnable 接口的方式：
   1. 避免了单继承的局限性。
   2. 实现了 Runnable 与 Thread 类的**解耦**，代码可以被多个线程共享，代码和线程独立。
   3. 多个线程可以共享同一个对象，降低了性能开销





### Java停止线程的方式

1. stop() 强制停止，suspend() 和 resume() 容易死锁 **都已经弃用**
2.  volatile 修饰标记位停止方法也是错误的，因为**线程被阻塞时感受不到标记位的变化**
3. **正确的停止线程的方式**：使用 interrupt。 interrupt 仅仅起到**通知被停止线程**的作用，并不强制停止。
4. 当一个线程处于阻塞状态（如调用了 `sleep()`、`wait()` 或 `join()` 方法）时，如果其他线程中断了该线程，就会抛出 `InterruptedException`。
5. 不能盲目吞掉中断，**正确的处理异常方法**：要不抛出，要不在 catch 中再次中断



### Java中线程的生命周期（六种状态）

1. New（新创建）：刚被创建尚未启动
2. Runnable（可运行）：对应操作系统中的 Running 和 Ready，也就是说，处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。
3. Blocked（被阻塞）：**没有抢到锁**，因此被阻塞
   1. 进入 synchronized 保护的代码时没有抢到 monitor 锁
   2. Waiting 或 Timed Waiting 被  **notify() 和 notifyAll() 唤醒时，先进入阻塞状态**，争抢到锁之后才会进入 Runnable
4. Waiting（等待）：没有设置等待时间，而是**等待某个条件**
   1. 没有设置 Timeout 参数的 Object.wait() 方法。
   2. 没有设置 Timeout 参数的 Thread.join() 方法。
   3. LockSupport.park() 方法。
5. Timed Waiting（计时等待）：设置了时间参数的等待
   1. 设置了时间参数的 Thread.sleep(long millis) 方法；
   2. 设置了时间参数的 Object.wait(long timeout) 方法；
   3. 设置了时间参数的 Thread.join(long millis) 方法；
   4. 设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。
6. Terminated（被终止）：线程退出 或 异常终止



### sleep()和wait()的区别

- 相同点
  1. 一旦执行，两者都会使得当前线程结束执行状态，进入阻塞状态。
- 不同点
  1. 是否释放锁：**`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 
  2. 所属的类：sleep() 在 Thread 中定义； wait() 在 Object 中定义
  4. 结束等待：sleep() 指定时间一到会自动苏醒；wait() 如果不指定时间，就会无限等待直到 notify 或 notifyAll。



### 六种常见线程池



1. FixedThreadPool

   核心线程数和最大线程数是一样的，所以可以把它看作是**固定线程数**的线程池。

2. CachedThreadPool
   可缓存线程池，它的特点在于线程数是几乎可以**无限增加**的，当线程闲置时还可以对线程进行回收。

3. ScheduledThreadPool
   **定时或周期性**执行任务

4. SingleThreadExecutor
   单线程

5. SingleThreadScheduledExecutor
   单线程定时任务（定时缓存使用）

6. ForkJoinPool
   适合执行**递归的任务**（并行执行之后汇总结果），例如树的遍历、最优路径搜索
   每个线程都有一个**自己的双端队列来存储分裂出来的子任务**





### *线程池的7个核心参数

![file_1714283991173_492](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/file_1714283991173_492.png)

其中，自定义线程池的核心参数如下：
1.核心线程数(corePoolSize):线程池中一直保持活动的线程数。可以使用corePoolSize方法来设置。一般
情况下，可以根据系统的资源情况和任务的特性来设置合适的值。
2.最大线程数(maximumPoolSize):线程池中允许存在的最大线程数。可以使用maximumPoolSize方法来
设置。如果所有线程都处于活动状态，而此时又有新的任务提交，线程池会创建新的线程，直到达到最大线程
数。
3.空闲线程存活时间(keepAliveTime)：当线程池中的线程数量超过核心线程数时，如果这些线程在一定时间
内没有执行任务，则这些线程会被销毁，注意**核心线程不会被销毁**。可以使用keepAliveTime和TimeUnit方法来设置。
4.阻塞队列(workQueue)：用于存放等待执行的任务的阻塞队列。可以根据任务的特性选择不同类型的队
列，如LinkedBlockingQueue、ArrayBlockingQueue等。默认情况下，使用无界阻塞队列，即
LinkedBlockingQueue,但也可以根据需要设置有界队列。
5.线程工厂(threadFactory):用于创建线程的工厂。可以通过实现ThreadFactory接口自定义线程的创建逻
辑。
6.拒绝策略(rejectedExecutionHandler):当线程池无法接受新的任务时，会根据设置的拒绝策略进行处
理。常见的拒绝策略有AbortPolicy、DiscardPolicy、DiscardOldestPolicy和CallerRunsPolicy。



### 四种拒绝策略

1. 拒绝任务的时机：
   1. 调用 shutdown 等方法**关闭线程池后**，即便此时可能线程池内部依然有没执行完的任务正在执行，但是由于线程池已经关闭，此时如果再向线程池内提交任务，就会遭到拒绝。
   2. 线程池没有能力继续处理新提交的任务，也就是工作已经非常**饱和**的时候。
2. 四种拒绝策略
   1. AbortPolicy：直接**抛异常**，让用户感知到，RejectedExecutionException 
   2. DiscardPolicy：直接丢弃任务，可能造成数据丢失
   3. DiscardOldestPolicy：**丢弃任务队列中的头结点**，通常是存活时间最长的任务，腾出空间给新提交的任务，也可能造成数据丢失
   4. CallerRunsPolicy：把这个任务交于提交任务的线程执行，也就是**谁提交任务，谁就负责执行任务**。这样做主要有两点好处。
      - 第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。
      - 第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，给了线程池一定的缓冲期。



### *常用的阻塞队列

1. LinkedBlockingQueue
   无界队列， FixedThreadPool 和 SingleThreadExector 使用。

2. SynchronousQueue

   容量为零，自身不持有元素。CachedThreadPool 线程数可以无限增加，因此使用这种阻塞队列。
   每个生产者线程在放入元素时**必须等待**消费者线程来取走该元素，不然就会阻塞。

3. DelayedWorkQueue
   对应的线程池是 ScheduledThreadPool ，这两种线程池的最大特点就是可以延迟执行任务。
   DelayedWorkQueue 的特点是会**按照延迟的时间长短**对任务进行排序，方便按顺序执行。





### CPU密集型任务 和 IO密集型任务 适合的线程数量

1. CPU密集型任务指的是加密、解密、压缩、计算等一系列需要大量**耗费 CPU 资源**的任务。这样的任务最佳的线程数为 **CPU 核心数的 1~2 倍**。假设我们设置的线程数量是 CPU 核心数的 2 倍以上，因为计算任务非常重， CPU 的每个核心工作基本都是满负荷的，而过多的线程争抢CPU，这就会造成不必要的上下文切换，此时线程数的增多并没有让性能提升，反而由于线程数量过多会导致性能下降。

2. IO密集型任务的特点是并不会特别消耗 CPU 资源，但是 **IO 操作很耗时**，比如数据库、文件的读写，网络通信等任务。对于这种任务，**为了减少IO**，最大线程数一般会大于 CPU 核心数很多倍。

   ```
   线程数 = CPU 核心数 *（1+平均等待时间/平均工作时间）
   ```









### TODO

<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240416164312353.png" alt="image-20240416164312353" style="zoom:50%;" />





## Spring框架



### @Autowird 与 @Resource的区别

1. @Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解
2. @Autowired 默认是**按照类型**注入，而@Resource是**按照名称**注入



### 对于AOP的理解

1. AOP 就是面向切面编程，能够将那些与业务无关，但是共通的一些逻辑（**事务处理、日志管理、权限控制等**）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
2. Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理



### SpringBoot 如何（并发）处理请求

1. Tomcat 监听指定端口，接收 HTTP 请求，封装请求相关信息
2. Tomcat 作为 Servlet 容器，使用线程池来处理请求。每当有请求到达时，Tomcat 会从线程池中分配一个线程来处理该请求，，**转发请求到 DispatcherServlet**
3. servlet **过滤器**进行处理，根据请求的 URL 和 HTTP 方法**查找相应的 Controller**
4. Spring **拦截器**进行处理，执行 Controller 的方法（参数校验等）
5. Service dao 处理 返回







## MySQL



### MySQL基础架构



#### MySQL逻辑架构

![img](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/0d2070e8f84c4801adbfa03bda1f98d9-1584367388001.png)

1. 大体来说，MySQL 可以分为 **Server 层** 和 **存储引擎层**两部分。
2. Server 层包括**连接器、查询缓存、分析器、优化器、执行器**等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置**函数**（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
3. 而存储引擎层负责**数据的存储和提取**。其架构模式是**插件式**的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。



#### SQL的执行过程

1. 连接器：TCP握手，获取数据库连接（一般是长连接）
2. 查询缓存：效率比较低，8.0取消了
3. 分析器：
   1. 词法分析：识别语句中的关键字，表名等
   2. 语法分析：检查是否有语法错误
4. 优化器：优化语句执行效率；
   eg：有多个索引时，选择使用哪个；多表连接时，选择连接顺序；
5. 执行器：
   1. 判断执行权限
   2. 多次调用存储引擎接口

![image-20240320220936229](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240320220936229.png)



#### MySQL 数据如何存放在文件中（物理存储）

假设数据库a中有表b

- InnoDB模式
  1. MySQL 5.7 及之前： b.frm 存放表结构， b.ibd 存放数据和索引
  2. MySQL 8 之后：取消 .frm ，表结构合并到 b.ibd 中
- MyISAM模式
  1. 数据和索引分开存放：b.MYD (MYData) 存储数据，b.MYI (MYIndex)：存放索引
  2. MySQL 5.7 及之前： b.frm  存放表结构
  3. MySQL 8 之后：  b.xxx.sdi  存放表结构



#### InnoDB对比MyISAM

1. MySQL ⽀持多种存储引擎，常⽤的有 InnoDB、MyISAM、Memory、Archive、CSV等，默认的是InnoDB
2. InnoDB和MyISAM的对比![image-20240326140238710](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240326140238710.png)
3. MyISAM一般用于对事务完整性没有要求或者以SELECT、INSERT为主的应用
4. 两者的B+树实现方式也不同，一个是聚簇索引，一个是非聚簇索引





#### COUNT(*)、COUNT(1)与COUNT(具体字段)效率？

1. COUNT(*)、COUNT(1)本质上没有什么区别

2. 在MyISAM中，每张表都有一个meta信息存储了**row-count**值，复杂度是**O(1)**，一致性则由表级锁来保证

3. 在InnoDB中，因为InnoDB支持事务，采用**行级锁和MVCC**机制，需要采用**扫描全表**，是**O(n)**的复杂度

4. 在InnoDB中，如果采用COUNT(具体字段)，**优先采用二级索引**，不用回表，信息少效率高。

   



#### Delete、Drop、Truncate有什么区别

1. `delete`是删除特定行，逐行删除，**支持事务，可以回滚**
2. `drop`是完全删除表数据和结构，无法通过事务回滚
3. `truncate`用于删除表中的所有数据，但**保留表结构**，无法通过事务回滚



#### 主键的设计问题

1. 自增id的问题

   1. **可靠性不高**：存在自增ID回溯的问题
   2. **安全性不高**：非常**容易猜测**
   3. **性能差**：对应的信息需要在数据库**服务器端生成**
   4. **交互多**：业务还需要额外执行一次类似 last_insert_id() 的函数才能知道刚才插入的自增值，这需要多一次的
      网络交互
   5. **局部唯一**：自增ID是**局部唯一**，而不是全局唯一，分布式场景不可用

2. 一般不使用业务字段作为主键

3. 主键设计至少应该是全局唯一且是单调递增。

  4. 有序uuid

  5. **雪花算法**

     1. 第一位 占用1bit，其值始终是0，没有实际作用。
     2. 时间戳 占用41bit，精确到毫秒，总共可以容纳约69年的时间。
     3. 工作机器id 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。 
     4. 序列号  占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。





### MySQL索引与优化



#### *索引的底层数据结构为什么是B+树

1. Hash 索引：**不支持顺序**和范围查询，经常需要遍历整张表
2. 二叉查找树：添加时可能**变得不平衡**，退化为链表
3. 二叉平衡树 AVL：插入删除时进行旋转，**解决了平衡问题**，但**删除时代价太大**，效率低
4. 红黑树：性能高于AVL，适合在内存中存储，但**树太高，磁盘IO代价太大**
5. B树：非叶子结点有多个子树，因此**高度减小**，磁盘IO次数减少
   ![image-20240712151712417](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240712151712417.png)
6. B+树：
   1. B+树**非叶子节点不存数据**，降低树高度
   2. 将叶子节点使用指针连接成**双向链表**，范围查询更加高效

![image-20240712154209042](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240712154209042.png)





 



#### B+树的存储能力？为何一般查找只需1~3次磁盘IO

1. InnoDB存储引擎中页大小为16KB，一般键值对大小16B，因此一页大约存1000个键值对，假设一页存储1000行数据，一个深度为3的B+树能存大约**10亿条记录**。
2. 实际数据库中，B+树的高度一般是2-4层，但根节点一般**常驻在内存**中，因此一般是1-3次IO



#### 普通索引 VS 唯一索引

1. 查：采用普通索引还是唯一索引在性能上**基本上没有差别**
2. 改：只有普通索引的更新**可以使用change buffer** ，唯一索引的更新不能使用
3. 推荐**尽量选择普通索引**，但还需要**考虑业务**能不能确保唯一性



#### *什么是聚簇索引和二级索引

InnoDB 中，根据叶子节点的内容，索引类型分为主键索引和非主键索引。

1. 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为**聚簇索引**（clustered index）。
2. 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为**二级索引**（secondary index）或非聚簇索引。根据二级索引查找时，需要根据主键再查聚簇索引，即**回表**

![image-20240403233401198](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240403233401198.png)



#### *联合索引的最左匹配原则

1. 联合索引是指使用**多个列组合起来作为一个索引**。联合索引可以包含多列，但是查询时只能使用前缀列进行查询，即只有在查询中使用了联合索的前几个列，才能利用联合索引进行查询。**如果查询中没有使用前缀列，那么联合索引就不能发挥作用，需要使用单独的索引或全表扫描。**
2. 最左前缀匹配原则是指在查询时只能使用最左列进行匹配。例如，一个联合索引包含了A、B、C三列，那么查询时只能使用A、AB或ABC进行匹配，而不能只使用B或C进行匹配。这是因为如果查询时使用的列不是最左前缀列，那么MySQL就无法使用索引进行查询，会导致全表扫描，从而降低查询效率。



#### 适合创建索引的情况

1. 字段的数值有唯一性的限制
2. 频繁作为 WHERE 查询条件的字段
3. 经常 GROUP BY 和 ORDER BY 的列
4. UPDATE、DELETE 的 WHERE 条件列
5. DISTINCT 字段需要创建索引
6. 多表 JOIN 连接操作时创建索引
7. 使用列的类型小的创建索引
8. 使用字符串前缀创建索引
9. 区分度高(散列性高)的列适合作为索引
10. 使用最频繁的列放到联合索引的左侧(最左前缀原则)
11. 在多个字段都要创建索引的情况下，联合索引优于单值索引



#### 不适合创建索引的情况

1. 在where中使用不到的字段，不要设置索引
2. 数据量小的表不需要使用索引，比如不到 1000 行
3. 有大量重复数据的列上不要建立索引
4. 避免对经常更新的表创建过多的索引
5. 不建议用无序的值作为索引
6. 删除不再使用或者很少使用的索引
7. 不要定义冗余或重复的索引



#### 覆盖索引/索引覆盖是什么意思？ 优缺点

1. 覆盖索引是指一个**索引包含了查询结果**，在索引中就能获得需要查询的数据
2. 优点：减少回表次数，效率高，避免了回表产生的随机IO
3. 缺点：索引维护的代价



#### 什么是索引条件下推ICP

1. 索引下推：MySQL优化器将部分带有索引的条件交由**存储引擎层进行判断**，**减少回表查询次数**，提高查询效率。
2. 将本来在Server层的操作，交由存储引擎层，因此叫做下推。
3. 例子：假设有一个名为students的学生表，其中包含学生的姓名、年龄和成绩等信息。我们需要查询年龄在18到25岁之间，
   并且成绩在80分以上的学生。如果age和score字段上分别有索引，那么使用索引下推的查询可以如下所示：
   SELECT name,age,score FROM students WHERE age BETWEEN 18 AND 25 AND score >=80;
   - 当MySQL没有使用索引下推，步骤如下：
     1)通过索引age找到多条主键ID分别是(1、3、5、6)数据
     2)再通过主键ID分别进行回表查询出来[有四个主键ID需要回表4次]
     3)再将数据交由Server层，将满足score的数据过滤出来得到最终数据
   - 当MySQL使用了索引下推，步骤如下：
     1)通过索引age找到多条主键ID分别是(1、3、5、6)数据
     2)由于score字段也拥有索引，**存储引擎直接通过score>=80来进行索引过滤**，分别找到多条数据(3、5)
     3)出来得到最终结果[有两个主键ID需要回表2次]
4. 需要注意的是：
   1)索引下推只能在InnoDB和MyISAM这两个存储引擎中生效。
   2)如果有子查询不生效
   3)如果有存储函数也不生效
   4)如果使用聚簇索引（主键）查询，索引下推也不会生效，因为其是对于非聚簇索引来进行减少回表次数。



#### 隐藏索引对于调优有什么意义

1. 隐藏索引是MySQL8.0的新特性
2. 当一个索引被隐藏时，它不会被查询优化器所使用。也就是说，管理员可以隐藏一个索引，然后观察对数据库的影响，再决定是否删除。





#### 多表连接，如何创建索引

1. 首先， 连接表的数量尽量**不要超过 3 张** ，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。
2. 其次， 对 WHERE 条件创建索引 ，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。
3. 最后， 对用于连接的字段创建索引 ，并且该字段在多张表中的 **类型必须一致** 。比如 course_id 在student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。



#### 多表连接，如何优化查询

1. 先按照各自的条件对两个表进行过滤，按照数据行数判断表大小

2. **小表驱动大表**，选择小表作为驱动表可以减少需要处理的数据量，提高查询性能。

   



#### *数据库的优化步骤

1. 数据库和引擎层面：
   - 对事务或安全性要求高：Oracle
   - 对并发要求高 成本低：MySQL -> InnoDB / MyISAM (事务、外键、行锁)
2. 优化表设计：数据类型、范式、多表查询 -> 反范式
3. 优化SQL查询语句
   - 逻辑查询：小表驱动大表
   - 物理查询：建立优化索引、最左前缀原则
4. 性能分析优化：
   1. 参数优化
   2. 慢查询日志
   3. explain 查看执行计划 key是否使用索引 使用哪个索引 rows查询的行数

5. 业务层面：使用 Redis 或 Memcached 作为缓存
6. 优化数据库架构：主从复制、读写分离、分库分表、冷热数据分离等



#### 如何做大表优化

1. 限定查询的范围：禁止不带任何限制数据范围条件的查询语句。比如：限制查询订单历史，控制在一个月的范围内
2. 读写分离：
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240430232500794.png" alt="image-20240430232500794" style="zoom: 67%;" />
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240430232522859.png" alt="image-20240430232522859" style="zoom:67%;" />
3. 分库分表
   1. 垂直拆分：如果列太多，可以将一张表拆成多张
      - 垂直拆分的优点： 可以使得列数据变小，减少I/O次数。
      - 垂直拆分的缺点： 主键会出现冗余，并会引起 JOIN 操作。此外，垂直拆分会让事务变得更加复杂。
   2. 水平拆分：控制单表数据量的大小，例如1000万条数据一张表



#### 索引失效的几种情况

1. **使用不等于运算符**:
   - 使用 `<>` 或 `!=` 运算符时，索引可能无法有效利用。
2. **使用范围查询**:
   - 使用范围查询（如 `BETWEEN`、`<`、`>`）时，索引可能会被部分利用，但效率降低。
3. **函数或表达式**:
   - 在查询中对索引列使用函数或表达式（如 `WHERE YEAR(date_column) = 2023`）会导致索引失效。
4. **模糊查询**:
   - 使用 `LIKE` 进行前缀匹配时（如 `LIKE '%abc'`），索引失效；但 `LIKE 'abc%'` 可以利用索引。
5. **NULL 值**:
   - 在索引列中存在 `NULL` 值时，某些查询可能无法利用索引。
6. **低选择性列**:
   - 对于选择性低的列（如性别、状态等），索引的效果可能不明显。
7. **JOIN 操作**:
   - 在多表连接时，如果连接条件不使用索引列，可能导致索引失效。
8. **ORDER BY 和 GROUP BY**:
   - 如果 `ORDER BY` 或 `GROUP BY` 的列没有索引，可能导致索引失效。
9. **更新或删除操作**:
   - 对索引列进行更新或删除操作时，可能导致索引失效，尤其是在频繁更新的情况下。



### MySQL事务



#### 事务的基本概念

1. MySQL存储引擎中，只有InnoDB支持事务
2. 事务是**一组操作**，要么全部执⾏成功，要么全部失败回滚
3. 事务的ACID四大特性



#### *事务四大特性 ACID

1. 原子性（Atomicity）：事务是⼀个原子操作，**不可分割，没有中间状态**，要么全部提交，要么全部回滚。
   --> **undo log** 实现回滚

2. ⼀致性（Consistency）：⼀致性是指在事务中，确保数据的**约束条件**。

   - 例子1：如 A 给 B 转账，存在约束：不论如何存款总额必须不变。如果存款总额发生变化，必须回滚。
   - 例子2：如 A 账户扣款，存在约束： A 账户余额不能小于0。如果 A 余额小于0，必须回滚。

3. 隔离性（Isolation）：多个事务**并发**访问时，事务之间是**隔离**的，⼀个事务的执行不能被其他事务所干扰。

   --> **并发问题 隔离级别 锁** 

4. 持久性（Durability）：⼀旦事务提交，其所做的修改必须永久保存到数据库中。不可回滚，即使系统发⽣故障或宕机， 数据也能够保持不变。持久性是通过**事务日志**来保证的。
   --> **redo log** 实现持久性



#### 四种数据并发问题

按照严重性来排序：脏写 > 脏读 > 不可重复读 > 幻读
脏：读写了脏数据，对方回滚了 ；幻：读了新插入的

1. 脏写：事务 A 修改了另一个未提交事务 B 修改过的数据，之后如果 B 回滚， A 的修改也消失

   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240709180253138.png" alt="image-20240709180253138" style="zoom: 50%;" />

2. 脏读： A 读取了已经被 B 更新但还没有被提交的字段。之后如果 B 回滚， A 读取 的内容就是 临时且无效 的。A 就相当于读到了一个不存在的数据。
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240709180845753.png" alt="image-20240709180845753" style="zoom:50%;" />

3. 不可重复读：A 读取了一个字段，然后 B **更新**了该字段。 之后 A 再次读取同一个字段，值就不同了。那就意味着发生了不可重复读。
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240709182226460.png" alt="image-20240709182226460" style="zoom:50%;" />

4. 幻读：A 从一个表中读取了一个字段, 然后 B 在该表中**插入**了一些新的行。 之后, 如果 A 再次读取同一个表, 就会多出几行。那就意味着发生了幻读。
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240709182439808.png" alt="image-20240709182439808" style="zoom:50%;" />





#### *SQL中的四种隔离级别

SQL标准中设立了4个隔离级别，以**在并发性能和隔离性之间作取舍**

1. READ UNCOMMITTED ：**读未提交**，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。
2. READ COMMITTED ：**读已提交**，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的**默认隔离级别**。
3. REPEATABLE READ ：**可重复读**，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。这是**MySQL的默认**隔离级别。
4. SERIALIZABLE ：**可串行化**，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。

<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/QQ_1720538804023.png" alt="QQ_1720538804023" style="zoom:50%;" />

以上四种隔离级别都能**避免脏写**问题

需要注意MySQL的实现中 REPEATABLE READ 解决了幻读的问题 -> **MVCC**

<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/QQ_1720538864288.png" alt="QQ_1720538864288" style="zoom:50%;" />



#### *MySQL事务日志 redo undo

1.  redo log
   1. redo log 可以保证事务的**持久性**
   2. redo log 简单来说就是：将事务修改的东西记录下来，写入磁盘。这样即使系统崩溃，也能重启后通过日志恢复。
   3. 优点：降低了刷盘频率，占用空间小，保证持久性
   4. redo log 也分为 redo log buffer 和 redo log file ，区别是保存在内存中和磁盘中，redo log buffer 以一定频率写入磁盘 -> 刷盘策略
   5. ![image-20240711152953622](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240711152953622.png)
   6. **Write-Ahead Log**(预先日志持久化)：在持久化一个数据页之前，先将内存中相应的**日志页**持久化
   7.  redo log 的刷盘策略：默认为1，**事务提交时**将 redo log buffer 刷盘，可以完全保证事务的持久性
2. undo log
   1. undo log 可以保证事务的**原子性**
   2. undo log 的作用：
      1. **回滚数据**：事务执行过程中 出错回滚 或 手动 rollback 。需要注意undo log 只能**逻辑恢复** 不能物理恢复
      2. **MVCC**
   3. <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240711170758268.png" alt="image-20240711170758268" style="zoom: 50%;" />





#### MySQL其他常见日志

1. 慢查询日志
2. 通用查询日志、错误日志
3. 中继日志
4. **二进制日志 bin log**
   1. bin log 是 Server 层生成的日志，记录了增删改操作，主要用于**数据恢复和主从复制**
   2. redo log 是物理日志，记录物理磁盘的变化；binlog 是**逻辑日志**，记录逻辑变化（SQL语句）
   3. 为了解决 redo log 和 binlog 的**一致性问题**，使用**两阶段提交**，将写入 redo log 分为 prepare 和 commit 两个阶段，先写入 redo log 状态为 prepare， 再写入 bin log ，最后将 redo log 更改为 commit



#### *锁的分类

*重点：**意向锁**、**悲观锁和乐观锁**

1. 按照**操作类型**分：
   1. 读锁：**共享锁**、S锁。针对同一份数据，多个事务的读操作可以同时进行，相互不阻塞的。
   2. 写锁：**排他锁**、X锁。当前写操作没有完成前，它会**阻断其他写锁和读锁**。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

2. 按照**操作粒度**分：
   1. 表级锁
      1. 表级的S锁和X锁
      2. **意向锁**
         1. ⽤于协调事务对表的锁定。一个事务对某些行添加排他锁时，数据库会自动给这行所在的数据表加上意向排他锁，**目的是告诉其他人这个表已有排他锁了**，其他事务想获取数据表排他锁的时候，判断表的意向锁即可，**不用遍历表中的每一行，提高效率**
         2. 意向锁**由存储引擎自己维护**
         3. 意向锁在**保证并发性**的前提下，实现了 行锁和表锁共存**（多粒度锁）** 且 **满足事务隔离性** 的要求
      4. 元数据锁（MDL锁）
         1. MDL 锁的作用是，避免读写表的时候元数据（表结构）变更。
         2. 因此，**当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。**
         3. MDL 锁不需要显式使用
      
   2. 行锁（InnoDB）

      优点：粒度细，并发性能好

      缺点：锁开销较大，容易死锁

      1. 记录锁
         只锁某条记录，也分为 S 和 X 
   
      2. 间隙锁
         MySQL 为了在 REPEATABLE READ 隔离级别下**解决幻读**问题
         ① MVCC
         ② 间隙锁
   
      3. 临键锁
         临键锁 = 间隙锁 + 记录锁 
   
      4. 插入意向锁

         **InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构**，表明有事务想在某个间隙中插入新记录，但是现在在等待。

   3. 全局锁
      Flush tables with read lock (FTWRL)
      对整个库做备份时可能用到
   
3. 按照**对待态度**划分：
   乐观锁和悲观锁是两种锁的**设计思想**

   1. 悲观锁
      1. 总是设想最坏的情况，在读取数据时加锁
      2. 通过数据库的**锁机制实现**
      3. 适合 **写操作多** 的场景

   2. 乐观锁
      1. 乐观锁假设多个事务不会同时修改同一个数据，不需要在读取数据时加锁，提交更新时才检查数据是否被其他事务修改过
      2. **通过程序实现**，版本号机制、时间戳机制、CAS
      3. 适合 **读操作多** 的场景

4. 按加锁方式分：

   1. 隐式锁

      隐式锁是一种延迟加锁的机制，从而来减少加锁的数量。隐式锁在实际内存对象中并不含有这个锁信息。只有当产生锁等待时，隐式锁转化为显式锁。

   2. 显式锁
      通过语句加的S锁或X锁



#### *什么是MVCC

1. 定义：MVCC就是**多版本并发控制**。MVCC 是通过数据行的多个版本管理来实现数据库的 并发控制
2. MySQL中可重复读级别下，通过 MVCC，**解决了幻读**的问题
3. 并发性能：InnoDB中使用 MVCC 而不是锁来**处理读写冲突**，**并发性能**更好
4. **MVCC = 两个隐藏字段 + undo 版本链 + read view + 快照读**
5. 两个隐藏字段：最近修改事务 ID 、回滚指针
6. 读已提交：每次读都创建新 read view; 可重复读：只创建一次 read view 







## Redis缓存



### *MySQL 和 Redis 的区别

1. 数据库类型：关系型和非关系型，键值存储和表格存储
2. 性能：Redis 内存中 读写快，MySQL 比较慢
3. 使用场景：Redis：缓存、高并发；MySQL：事务、关联查询、数据一致性



### *Redis 的数据结构

**5 种基础数据类型**：String、List、Set、Hash、Zset

**3 种特殊数据类型**：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)

![img](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/8219f7yy651e566d47cc9f661b399f01-20221015222815-uayktlp.jpg)

- 字符串的底层实现

  1. 整数采用 INT 编码；
  2. 如果 SDS 内容 < 44 字节，采用 EMBSTR 编码，object head 和 SDS 在内存中连续存储，加上头的大小正好64字节，可以节省一次内存分配，效率更高；
  3. 第三种方式是 RAW ；

  ![image-20240906015235153](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906015235153.png)

- List列表的底层实现

  1. 使用 QuickList 实现，QuickList = **双向链表+ZipList**
  2. 由于采用 ZipList 压缩列表，内存占用较小；中间节点可以压缩，进一步节省了内存
  3. ZipList 的内存空间连续，效率较高，寻址采用上一节点和本节点长度计算

  ![image-20240906015324088](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906015324088.png)

- Set 的底层实现

  1. 如果存储的所有数据都是整数，使用 IntSet 整数数组实现，**类型升级机制**
  2. 为了查询效率和唯一性，set 采用 HT编码/Dict/哈希表。可以**类比**：Java 中 HashSet 的底层实现是 HashMap 。
  3. Dict其中包含两个哈希表，键值对中的key用来存储元素，value统一为null。
  4. **哈希表扩容 -> 切换、渐进式 rehash** 。

  ![image-20240906015403317](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906015403317.png)

- Zset/Sorted Set 的底层实现：根据 score 排序，member 值必须唯一，根据 member 查询 score

  1. 当**数据较少**（满足元素数量和元素大小的条件）时，底层使用 **ZipList 实现，节省内存**
  2. 当数据较多，**SkipList 和 Dict** 都不能同时满足三种要求，虽然编码是 SkipList ，但实际上是**结合使用**
  3. 数据较少时，查询效率区别不大；数据较多时，需要提高查询效率，因此牺牲一定内存，**以空间换时间**

  ![image-20240906015542348](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906015542348.png)

- Hash 的底层实现

  1. 当数据项比较少的情况下，Hash底层使用压缩列表 ZipList 进行存储数据，ZipList 中相邻的两个 entry 分别保存 field 和 value 
  2. 随着数据的增加，底层的 ZipList 就可能会转成 Dict 哈希表
  3. aaaf

  ![image-20240906021304608](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906021304608.png)



### *Redis 底层数据结构

- 简单动态字符串SDS：String 的底层实现

  1. 结构体中除了数据，还**保存了字符串长度**，分配的内存大小，类型
     ![image-20240830200814670](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240830200814670.png)

  2. 支持**动态扩容**，减少内存分配次数（内存分配比较消耗性能）

     > 如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；
     >
     > 如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。

- IntSet：特殊的整数数组，Set 的底层实现之一

  1. 其中元素唯一、有序，内存空间连续，**适合存放少量的数据**
  2. **类型升级机制**（扩容后**倒序拷贝**），节省内存空间
  3. 底层二分查找

- Dict：字典，基于哈希表

  1. Redis 使用 **dict** 来**保存所有键值对**，使用**链式哈希**解决哈希冲突。
  2. 为了使 rehash 操作更高效，Dict 默认使用了**两个哈希表**，用于切换扩容。
  3. 负载因子达到条件时，如果没有子进程任务，会触发**渐进式 rehash**，每处理一个请求时，**拷贝一条链表**的键值对到新哈希表。

  ![image-20240906014548667](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906014548667.png)

- ZipList：压缩列表

  1. 可以看做一种**连续内存空间**的"双向链表"，访问时效率较高
  2. 为了**节省内存**，不使用指针连接节点，而是记录**上一节点和本节点长度**来寻址
  3. 如果数据过多，会影响查询性能（链表的原理）
  4. 可能发生**连续更新问题**

  ![image-20240906014631825](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906014631825.png)

- QuickList：**List的底层实现**

  1. **双向链表+ZipList**：是一个双端链表，其节点为ZipList
  2. 由于采用ZipList，内存占用较小
  3. 中间节点可以压缩，进一步节省了内存

  ![image-20240906014653884](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906014653884.png)

- SkipList：跳表

  1. 一个有序的双向链表
  2. 每个节点都可以包含多层指针，层数1到32之间
  3. 不同层指针到下一个节点的跨度不同，层级越高，跨度越大
  4. 增删改查效率与红黑树（二分）基本一致，实现却更简单

  ![image-20240906014714327](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906014714327.png)

  ![image-20240906014724460](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906014724460.png)

- 什么是 RedisObject

  1. Redis中的**任意数据类型的键和值**都会被封装为一个RedisObject，也叫做Redis对象
     ![image-20240906012743738](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240906012743738.png)










### 什么是缓存穿透

缓存穿透是指客户端请求的**数据在缓存中和数据库中都不存在**，这样缓存永远不会生效，这些请求都会打到数据库。

解决方法：

1. 缓存空对象，设置一个较短TTL时间
   - 优点：实现简单
   - 缺点：内存消耗较多，可能造成短期数据不一致
2. 布隆过滤器
   - 优点：内存占用较少
   - 缺点：实现比较复杂，并不是百分百准确
3. 在业务层面添加校验等



### 什么是缓存雪崩

缓存雪崩是指在**同一时段大量的缓存key同时失效或者Redis服务宕机**，导致大量请求到达数据库，带来巨大压力。

解决方案：

1. 给不同的Key的TTL添加随机值
2. 利用Redis集群提高服务的可用性
3. 给缓存业务添加降级限流策略
4. 给业务添加多级缓存



### 什么是缓存击穿（热点key问题）

缓存击穿问题也叫热点Key问题，就是**一个被高并发访问并且缓存重建业务较复杂的key突然失效了**，无数的请求访问会在瞬间给数据库带来巨大的冲击。

解决方案：互斥锁/逻辑过期

<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/QQ_1722415217299.png" alt="QQ_1722415217299" style="zoom:50%;" />

<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/QQ_1722415231009.png" alt="QQ_1722415231009" style="zoom:50%;" />



###     *Redis 如何实现分布式锁

1. Redis 简单实现（不可重入）：set nx ex 

   1. nx 满足互斥性
   2. ex 保证故障时锁也能正常释放
   3. 判断锁中的线程标识（UUID + 线程ID 实现分布式）是否与自身一致，避免释放其他线程的锁
   4. 使用lua脚本实现原子性

2. Redission 实现优化（可重入）：

   1. 重入：使用 hash 结构记录线程ID和**重入次数**，重入一次 value + 1 ，释放一次 value - 1，value = 0 时释放锁
   2. 重试：在等待时间内，获取失败则**订阅锁释放的消息**，其他线程**释放锁时发布消息**，等待唤醒则再次获取锁，实现失败重试
   3. 超时续约：利用 watchDog 看门狗机制，将需要超时续约的锁放入一个 ConcurrentHashMap，使用定时任务，每隔⼀段时间(releaseTime/3)，重置超时时间，直到锁释放

3. Redisson 的 multilock

   1. 多个独立的Redis节点，必须全部节点都获取锁成功
   2. 解决主从一致性问题

   

   

### 3种常用的缓存读写策略

1. Cache Aside Pattern（旁路缓存模式）
   以数据库的结果为准，平时使用比较多，适合读请求比较多的场景

   1. 写操作：
      1. 更新数据库
      2. 删除缓存
   2. 读操作：
      1. 先读缓存
      2. 没有的话读数据库
      3. 结果写入缓存

2. Read/Write Through Pattern （读写穿透）

   把 cache 视为主要数据存储，在缓存中读写。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责

   1. 写操作：
      1. 先查缓存，如果不存在，直接写到数据库
      2. 如果缓存存在，更新缓存，由缓存自己更新数据库
   2. 读操作：
      1. 先读缓存
      2. 没有的话，读数据库，写入缓存

3. Write Behind Pattern（异步缓存写入）

   1. 异步批量的方式来更新 db
   2. 数据一致性可能有问题
   3. MySQL 的 Innodb Buffer Pool 机制



### *Redis 的持久化

1. RDB
   1. 内存中的数据做**全量快照**，记录到磁盘中
   2. 开一个**子进程**后台RDB，不影响主线程其他操作
   3. 子进程需要 **fork 主进程**得到，fork 采用的是 **copy-on-write 写时复制** 技术，确保不出现脏数据
2. AOF
   1. 记录对数据的逻辑操作，文件体积较大（可以通过日志文件重写解决）
   2. 三种回写策略：**可靠性和性能的平衡**
      ![img](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/72f547f18dbac788c7d11yy167d7ebf8-20221015222953-zr62sjp.jpg)
   3. 写时复制 **一个拷贝，两处日志**

![image-20240818120149339](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240818120149339.png)









## 消息队列



### *为什么使用消息队列？优势？

1. 异步处理：一旦生产者发送完消息，便可以立即转向其他任务，而消费者侧可以在任何时候开始处理消息。这样一来，生产者和消费者之间就**不会发生阻塞**。
2. 削峰填谷：先将请求存储起来，然后消费者可以根据**自身的处理能力**和需求，以一定速率，逐步从队列中取出并处理请求。
3. 数据持久化：它能将我们的消息集中**存储到硬盘**里，因此服务器重启后，数据不会丢失。就如同快递一样，即使丢失，也有一定的机制能帮你找回，这是分布式消息队列的首要优势。
4. 可扩展性：这是分布式与单机最大的区别。分布式的特点就是可以**根据需求随时增加或减少节点**，以保特服务稳定。
5. 应用解耦：这是在分布式场景下才能实现的功能，它允许各个使用**不同语言框架**开发的系统之间进行灵活的数据传输与读取。
   







## 设计模式



### 单例模式 饿汉式与懒汉式

1. 饿汉式：立即加载，即在使用类的时候已经将对象创建完毕。没有多线程安全问题，但耗费内存。
2. 懒汉式：延迟加载，即在调用静态方法时实例才被创建。节约内存，但线程不安全。









## 操作系统

### 死锁是什么？如何预防和避免死锁？

1. 死锁是指两个或多个进程在执行过程中因争夺资源而造成的⼀种僵局，当进程处于死锁状态时，它们将无法继续执行，只能相互等待，直到被外部的程序干预或自行放弃。
2. 四个产生死锁的必要条件
   1. 互斥
   2. 持有并等待
   3. 不可剥夺
   4. 环路等待
3. 避免死锁只需要破除四个条件中的一个





## 计算机网络

### 计算机网络七层模型

![image-20240422235122844](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240422235122844.png)



### 各层的常见协议

#### 应用层

![应用层常见协议](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/application-layer-protocol.png)

**HTTP（超文本传输协议）**：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 **浏览器与服务器之间的通信**而设计的。

**SMTP（简单邮件发送协议）**：基于 TCP 协议，是一种用于**发送电子邮件**的协议。

**POP3/IMAP（邮件接收协议）**：基于 TCP 协议，两者都是**负责邮件接收**的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。

**FTP（文件传输协议）** : 基于 TCP 协议，是一种用于**在计算机之间传输文件**的协议，可以屏蔽操作系统和文件存储方式。

**SSH（安全的网络传输协议）**：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。

**RTP（实时传输协议）**：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的**实时传输数据**的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。

**DNS（域名管理系统）**: 基于 UDP 协议，用于解决**域名和 IP 地址的映射**问题。



#### 传输层

![传输层常见协议](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/transport-layer-protocol.png)

- **TCP（传输控制协议 ）**：提供 **面向连接** 的，**可靠** 的数据传输服务。
- **UDP（用户数据协议）**：提供 **无连接** 的，尽最大努力的数据传输服务，**不保证可靠性**，简单高效。



#### 网络层

![网络层常见协议](https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/nerwork-layer-protocol-VpGZIByy.png)

**IP（网际协议）**：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。过去的 IPv4和较新的 IPv6。

**ARP（地址解析协议）**：IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 **IP 地址转 MAC 地址**的一些问题。

**ICMP（互联网控制报文协议）**：一种用于传输网络状态和错误消息的协议，常用于**网络诊断和故障排除**。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。

**NAT（网络地址转换协议）**：NAT 协议的应用场景如同它的名称——网络地址转换，应用于**内部网到外部网的地址转换**过程中。



### 从输入 URL 到页面展示到底发生了什么？

总体来说分为以下几个步骤:

1. 在浏览器中输入指定网页的 URL。
2. 浏览器通过 **DNS 协议**，递归，获取域名对应的 IP 地址。
3. 浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。
4. 浏览器在 **TCP 连接**上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。
5. 服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。
6. 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
7. 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。



### Http常见状态码

<img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240425130050771.png" alt="image-20240425130050771" style="zoom: 67%;" />

- **2xx Success（成功状态码）**

  - **200 OK**：请求被成功处理。比如我们发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。
  - **201 Created**：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。
  - **202 Accepted**：服务端已经接收到了请求，但是还未处理。
  - **204 No Content**：服务端已经成功处理了请求，但是没有返回任何内容。

- **3xx Redirection（重定向状态码）**

  - **301 Moved Permanently**：资源被永久重定向了。比如你的网站的网址更换了。
  - **302 Found**：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。

- ### 4xx Client Error（客户端错误状态码）

  - **400 Bad Request**：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。
  - **401 Unauthorized**：未认证却请求需要认证之后才能访问的资源。
  - **403 Forbidden**：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。
  - **404 Not Found**：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。
  - **409 Conflict**：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。

- ### 5xx Server Error（服务端错误状态码）

  - **500 Internal Server Error**：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。
  - **502 Bad Gateway**：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。

  


### HTTP 和 HTTPS 的主要区别

1. 端口：80 和 443
2. 性能：HTTPS 由于加了加密这一步，性能略低
3. 安全性：HTTP 是明文传输，容易被窃听篡改；HTTPS 使用 SSL/TLS 加密协议，数据在传输过程中是加密的
4. 加密方法：使用数字证书对内容加密，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用第三方服务器颁发的数字证书进行了非对称加密。







## 其他



### 常见的限流策略

限流，也称流量控制。是指系统在面临高并发，或者**大流量请求**的情况下，**限制新的请求对系统的访问**，从而**保证系统的稳定性**。

1. **固定窗口**限流算法
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240414205227933.png" alt="image-20240414205227933" style="zoom:50%;" />
   缺点：会遇到**临界问题**

2. **滑动窗口**限流算法
   将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/file_1713099278363_702.png" alt="file_1713099278363_702" style="zoom:50%;" />
   缺点是：会损失一部分请求

3. 漏桶算法
   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240414210109880.png" alt="image-20240414210109880" style="zoom:50%;" />
   缺点：**处理效率恒定**，无法迅速处理一批请求

4. 令牌桶算法

   较为常用的算法，能够**较好的处理高并发问题**

   - 有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。
   - 如果令牌数量满了，超过令牌桶容量的限制，那就丢弃。
   - 收到一个请求，先去令牌桶要一个令牌。
   - 如果拿到令牌，处理请求。如果拿不到令牌，拒绝请求。

   <img src="https://cora-typora-test-2023.oss-cn-shanghai.aliyuncs.com/pics/image-20240414210251103.png" alt="image-20240414210251103" style="zoom:50%;" />

   



## 手撕算法



### 两个线程交替打印1-100



```java
/**
 * 线程交替打印数字
 */
public class Print100Number {
    private static final Object lock = new Object();
    private static int number = 1;

    public static void main(String[] args) {
        new Thread(() -> {
            while (number <= 100) {
                synchronized (lock) {
                    if (number % 3 == 1) {
                        System.out.println(Thread.currentThread().getName() + number++);
                        lock.notifyAll();
                    } else {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        }, "打印1：").start();
        new Thread(() -> {
            while (number <= 100) {
                synchronized (lock) {
                    if (number % 3 == 2) {
                        System.out.println(Thread.currentThread().getName() + number++);
                        lock.notifyAll();
                    } else {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        }, "打印2：").start();
        new Thread(() -> {
            while (number <= 100) {
                synchronized (lock) {
                    if (number % 3 == 0) {
                        System.out.println(Thread.currentThread().getName() + number++);
                        lock.notifyAll();
                    } else {
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        }, "打印3：").start();
    }
}
```

### 手写LRU



### 单例模式手写









